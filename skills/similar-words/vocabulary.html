<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>INTUITY - Word Choice Quiz</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Space+Grotesk:wght@600;700;800&display=swap" rel="stylesheet">
  <style>
    /* ORIGINAL DESIGN PRESERVED EXACTLY */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);
      min-height: 100vh;
      color: #f1f5f9;
      padding: 1rem;
      line-height: 1.6;
    }
    .container { max-width: 900px; margin: 0 auto; }
    .back-btn { display:inline-flex;align-items:center;gap:.5rem;color:#94a3b8;background:none;border:none;font-size:.875rem;cursor:pointer;margin-bottom:1rem;padding:.5rem 0;transition:color .2s; }
    .back-btn:hover { color:#cbd5e1; }
    .header { text-align:center; margin-bottom:1.25rem; }
    .logo { font-family:'Space Grotesk',sans-serif;font-size:2.5rem;font-weight:800;color:rgba(255,107,53,.9);letter-spacing:-.03em;margin-bottom:.25rem; }
    .subtitle { font-size:.8125rem;color:#94a3b8;margin-bottom:.125rem; }
    .author { font-size:.6875rem;color:#64748b; }
    .test-nav { display:flex;align-items:center;justify-content:center;gap:.75rem;margin-bottom:1rem;flex-wrap:wrap; }
    .nav-btn { width:2.25rem;height:2.25rem;border:none;background:rgba(71,85,105,.3);color:#94a3b8;border-radius:.5rem;cursor:pointer;font-size:1.125rem;transition:.2s;display:flex;align-items:center;justify-content:center; }
    .nav-btn:hover:not(:disabled){background:rgba(71,85,105,.5);color:#e2e8f0;}
    .nav-btn:disabled{opacity:.3;cursor:not-allowed;}
    .dots{display:flex;gap:.375rem;flex-wrap:wrap;max-width:400px;position:relative;}
    .dot{width:.625rem;height:.625rem;border-radius:50%;background:#475569;cursor:pointer;transition:.2s;}
    .dot:hover{background:#64748b;transform:scale(1.2);}
    .dot.active{background:rgba(255,107,53,.9);box-shadow:0 0 0 2px rgba(255,107,53,.2);}
    .dot.completed{background:#10b981;}
    .info-bar{text-align:center;color:#94a3b8;font-size:.8125rem;margin-bottom:1rem;font-weight:500;}
    .word-bank{display:flex;justify-content:center;gap:.375rem;margin-bottom:1rem;flex-wrap:wrap;max-width:100%;min-height:40px;position:sticky;top:0;background:linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #0f172a 100%);padding:1rem 0;z-index:10;border-bottom:1px solid rgba(71,85,105,.2);}
    .word-chip{background:rgba(255,107,53,.15);border:1px solid rgba(255,107,53,.3);color:rgba(255,107,53,.9);padding:.375rem .75rem;border-radius:.375rem;font-weight:600;font-size:.8125rem;transition:.2s;white-space:nowrap;cursor:move;user-select:none;}
    .word-chip.used{background:rgba(71,85,105,.3);border-color:rgba(71,85,105,.5);color:#64748b;text-decoration:line-through;cursor:not-allowed;}
    .word-chip.dragging{opacity:0.5;transform:scale(1.05);}
    .word-chip:hover:not(.used){transform:scale(1.05);background:rgba(255,107,53,.25);}
    @media(max-width:640px){.word-chip{padding:.3rem .6rem;font-size:.75rem;}.word-bank{gap:.3rem;}}
    .quiz-box{background:rgba(30,41,59,.6);backdrop-filter:blur(20px);border:1px solid rgba(71,85,105,.5);border-radius:1rem;padding:1rem;box-shadow:0 20px 25px -5px rgba(0,0,0,.5);}
    .sets-container{display:flex;flex-direction:column;gap:1.5rem;}
    .set-wrapper{background:rgba(30,41,59,.6);backdrop-filter:blur(20px);border:1px solid rgba(71,85,105,.5);border-radius:1rem;padding:1rem;box-shadow:0 20px 25px -5px rgba(0,0,0,.5);margin-bottom:1.5rem;}
    .set-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;padding-bottom:0.5rem;border-bottom:1px solid rgba(71,85,105,.2);}
    .set-title{font-size:1rem;font-weight:600;color:rgba(255,107,53,.9);}
    .set-progress{font-size:.8125rem;color:#94a3b8;}
    .question{background:rgba(15,23,42,.5);border:1px solid rgba(71,85,105,.3);border-radius:.625rem;margin-bottom:.625rem;overflow:hidden;transition:.3s;}
    .question-header{display:flex;align-items:center;gap:.75rem;padding:.75rem;}
    .question-num{width:1.75rem;height:1.75rem;border-radius:50%;background:rgba(255,107,53,.8);color:white;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:.8125rem;flex-shrink:0;}
    .question-num.answered{background:#3b82f6;}
    .question-num.correct{background:#10b981;}
    .question-num.incorrect{background:#f59e0b;}
    .question-text{flex:1;font-size:.875rem;line-height:1.5;}
    .blank{display:inline-block;min-width:70px;padding:.125rem .5rem;background:rgba(71,85,105,.4);border:1px solid rgba(71,85,105,.5);border-radius:.25rem;margin:0 .25rem;color:#94a3b8;font-weight:600;text-align:center;font-size:.8125rem;cursor:pointer;transition:all .2s;}
    .blank.filled{background:rgba(59,130,246,.2);border-color:rgba(59,130,246,.5);color:#60a5fa;}
    .blank.correct{background:rgba(16,185,129,.25);border-color:rgba(16,185,129,.6);color:#10b981;box-shadow:0 0 0 2px rgba(16,185,129,.2);}
    .blank.incorrect{background:rgba(249,115,22,.25);border-color:rgba(249,115,22,.6);color:#f97316;box-shadow:0 0 0 2px rgba(249,115,22,.2);}
    .blank.active{outline:2px solid rgba(255,107,53,.9);outline-offset:2px;}
    .blank.drag-over{transform:scale(1.05);background:rgba(255,107,53,.2);border-color:rgba(255,107,53,.5);}
    .controls{display:flex;justify-content:center;gap:.5rem;margin-top:1.25rem;flex-wrap:wrap;}
    .control-btn{padding:.5rem 1.25rem;border:none;background:rgba(255,107,53,.15);color:rgba(255,107,53,.9);border-radius:.375rem;cursor:pointer;font-size:.8125rem;font-weight:600;transition:.2s;font-family:'Inter',sans-serif;white-space:nowrap;}
    .control-btn:hover{background:rgba(255,107,53,.25);transform:translateY(-1px);}
    .loading,.error{text-align:center;padding:2rem;font-size:1rem;}
    .error{color:#f87171;}
    .loading{color:#94a3b8;}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:1000;padding:1rem;}
    .modal.active{display:flex;}
    .modal-content{background:#1e293b;border:1px solid rgba(71,85,105,.5);border-radius:1rem;padding:1.5rem;max-width:400px;width:100%;text-align:center;}
    .modal-title{font-size:1.375rem;font-weight:700;color:rgba(255,107,53,.9);margin-bottom:1rem;}
    .modal-stats{margin:1.25rem 0;font-size:1rem;color:#cbd5e1;}
    .modal-stat{margin:.375rem 0;}
    .modal-close{padding:.625rem 1.75rem;border:none;background:rgba(255,107,53,.2);color:rgba(255,107,53,.9);border-radius:.5rem;cursor:pointer;font-size:.9375rem;font-weight:600;margin-top:.75rem;font-family:'Inter',sans-serif;}
    .modal-close:hover{background:rgba(255,107,53,.3);}
    
    /* Enhanced navigation while keeping original style */
    .nav-dropdown{background:rgba(71,85,105,.3);border:none;color:#94a3b8;padding:.375rem .75rem;border-radius:.5rem;font-size:.8125rem;cursor:pointer;transition:.2s;margin:0 .25rem;}
    .nav-dropdown:hover{background:rgba(71,85,105,.5);color:#e2e8f0;}
    .nav-input{width:60px;background:rgba(71,85,105,.3);border:1px solid rgba(71,85,105,.5);color:#f1f5f9;padding:.25rem;border-radius:.375rem;font-size:.8125rem;text-align:center;margin:0 .25rem;}
    .shortcuts-hint{position:fixed;bottom:1rem;right:1rem;background:rgba(15,23,42,.9);border:1px solid rgba(71,85,105,.5);border-radius:.5rem;padding:.75rem;font-size:.75rem;color:#94a3b8;max-width:250px;z-index:100;}
    .gesture-indicator{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(255,107,53,.9);color:white;padding:1rem 2rem;border-radius:.5rem;font-weight:600;opacity:0;pointer-events:none;transition:opacity .3s;}
    .gesture-indicator.show{opacity:1;}
    
    /* Smooth scrolling for sets */
    .sets-container{scroll-behavior:smooth;}
    
    /* Visual feedback for keyboard navigation */
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,107,53,.4);}70%{box-shadow:0 0 0 10px rgba(255,107,53,0);}100%{box-shadow:0 0 0 0 rgba(255,107,53,0);}}
    .blank.keyboard-focus{animation:pulse 1s;}
  </style>
</head>
<body>
  <div class="container">
    <button class="back-btn" onclick="goBack()">‚Üê Back to Menu</button>
    <div class="header">
      <div class="logo">INTUITY</div>
      <div class="subtitle">Word Choice Quiz - B2 Level</div>
      <div class="author">by Majid Nashtai</div>
    </div>
    
    <!-- Enhanced Navigation - Visually fits original design -->
    <div class="test-nav">
      <button class="nav-btn" id="prevBtn" title="Previous Set (‚Üê)">‚Üê</button>
      <select class="nav-dropdown" id="jumpDropdown" title="Jump to any set">
        <option value="">Jump...</option>
      </select>
      <div class="dots" id="dotsContainer"></div>
      <input type="number" class="nav-input" id="gotoInput" placeholder="#" title="Go to set (Ctrl+G)">
      <button class="nav-btn" id="nextBtn" title="Next Set (‚Üí)">‚Üí</button>
    </div>
    
    <div class="info-bar" id="infoBar">Loading quiz...</div>
    <div class="word-bank" id="wordBank"></div>
    
    <!-- Multiple sets container -->
    <div id="setsContainer"></div>
    
    <!-- Enhanced controls -->
    <div class="controls">
      <button class="control-btn" onclick="checkAllVisible()">Check All Visible</button>
      <button class="control-btn" onclick="showResults()">Show Score</button>
      <button class="control-btn" onclick="resetAllVisible()">Reset Visible</button>
      <button class="control-btn" onclick="nextUnanswered()">Next Empty ‚á•</button>
      <button class="control-btn" onclick="saveProgress()">üíæ Save</button>
    </div>
  </div>
  
  <!-- Results Modal - Original Design -->
  <div class="modal" id="resultsModal">
    <div class="modal-content">
      <div class="modal-title">Quiz Results</div>
      <div class="modal-stats" id="resultsContent"></div>
      <button class="modal-close" onclick="closeModal()">Close</button>
    </div>
  </div>
  
  <!-- Shortcuts hint -->
  <div class="shortcuts-hint">
    <strong>Keyboard Shortcuts:</strong><br>
    1-9: Select word<br>
    Tab: Next blank<br>
    ‚Üê/‚Üí: Navigate sets<br>
    Ctrl+Enter: Check all<br>
    Ctrl+G: Go to set<br>
    Drag words to blanks!
  </div>
  
  <!-- Gesture indicator -->
  <div class="gesture-indicator" id="gestureIndicator"></div>
  
  <script>
    // Global state
    let quizData = null;
    let currentSetIndex = 0;
    let userAnswers = {};
    let checkedSets = new Set();
    let shuffledWords = {};
    let activeBlank = null;
    let visibleSets = [];
    const SETS_TO_LOAD = 5; // Load 5 sets at a time
    let totalLoaded = 0;

    // Initialize
    async function init() {
      try {
        // Try to load JSON file first
        const urlParams = new URLSearchParams(window.location.search);
        const jsonPath = urlParams.get('json') || '../datacentre/datasm-01.json';
        
        try {
          const response = await fetch(jsonPath);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          quizData = await response.json();
          if (!quizData.sets || quizData.sets.length === 0) throw new Error('No quiz sets found');
          console.log('‚úÖ Successfully loaded quiz from:', jsonPath);
        } catch (fetchError) {
          console.warn('‚ö†Ô∏è Could not load JSON file:', fetchError.message);
          console.log('üîÑ Using sample data for demonstration...');
          quizData = createSampleData();
        }
        
        // Shuffle words for each set
        quizData.sets.forEach((set, setIdx) => {
          shuffledWords[setIdx] = shuffleWords(set.words);
        });
        
        // Load saved progress
        loadSavedProgress();
        
        // Initialize navigation
        initializeEnhancedNavigation();
        
        // Setup keyboard shortcuts
        setupKeyboardShortcuts();
        
        // Setup touch gestures
        setupTouchGestures();
        
        // Setup drag and drop
        setupDragAndDrop();
        
        // Load initial sets
        loadMultipleSets(0, SETS_TO_LOAD);
        
        // Setup infinite scroll
        setupInfiniteScroll();
        
        updateInfoBar();
        
      } catch (error) {
        console.error('‚ùå Critical error loading quiz:', error);
        document.getElementById('setsContainer').innerHTML =
          `<div class="error">‚ùå Error loading quiz<br><small>${error.message}</small></div>`;
      }
    }

    // Sample data for demonstration when JSON file is not available
    function createSampleData() {
      return {
        sets: [
          {
            words: ["however", "moreover", "therefore", "although", "nevertheless"],
            sentences: [
              { text: "The weather was terrible, _____ we decided to go hiking.", correct: 0 },
              { text: "She studied hard _____ she failed the exam.", correct: 3 },
              { text: "He was tired; _____, he continued working.", correct: 4 }
            ]
          },
          {
            words: ["beautiful", "gorgeous", "stunning", "attractive", "pretty"],
            sentences: [
              { text: "The sunset was absolutely _____.", correct: 2 },
              { text: "She wore a _____ dress to the party.", correct: 0 },
              { text: "The garden looks _____ in spring.", correct: 4 }
            ]
          },
          {
            words: ["quickly", "rapidly", "swiftly", "fast", "speedily"],
            sentences: [
              { text: "The car moved _____ down the highway.", correct: 3 },
              { text: "She _____ finished her homework.", correct: 0 },
              { text: "The river flows _____ after the rain.", correct: 1 }
            ]
          },
          {
            words: ["important", "crucial", "vital", "essential", "significant"],
            sentences: [
              { text: "It's _____ to arrive on time for the meeting.", correct: 0 },
              { text: "Water is _____ for human survival.", correct: 2 },
              { text: "This discovery is _____ for medical research.", correct: 1 }
            ]
          },
          {
            words: ["happy", "joyful", "delighted", "cheerful", "pleased"],
            sentences: [
              { text: "She was _____ with the test results.", correct: 4 },
              { text: "The children looked _____ at the playground.", correct: 3 },
              { text: "We were _____ to hear the good news.", correct: 2 }
            ]
          }
        ]
      };
    }

    // Shuffle words helper
    function shuffleWords(originalWords) {
      const indices = Array.from(originalWords.keys());
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      const newWords = indices.map(idx => originalWords[idx]);
      const indexMap = {};
      indices.forEach((oldIdx, newIdx) => indexMap[oldIdx] = newIdx);
      return { words: newWords, indexMap };
    }

    // Enhanced navigation
    function initializeEnhancedNavigation() {
      // Populate jump dropdown
      const dropdown = document.getElementById('jumpDropdown');
      for (let i = 0; i < quizData.sets.length; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Set ${i + 1}`;
        dropdown.appendChild(option);
      }
      
      dropdown.addEventListener('change', (e) => {
        if (e.target.value !== '') {
          jumpToSet(parseInt(e.target.value));
        }
      });
      
      // Setup goto input
      const gotoInput = document.getElementById('gotoInput');
      gotoInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          const setNum = parseInt(e.target.value) - 1;
          if (setNum >= 0 && setNum < quizData.sets.length) {
            jumpToSet(setNum);
            e.target.value = '';
          }
        }
      });
      
      // Nav buttons
      document.getElementById('prevBtn').onclick = () => navigateSet(-1);
      document.getElementById('nextBtn').onclick = () => navigateSet(1);
      
      // Render dots (limited to 30 for visual clarity)
      renderDots();
    }

    // Render navigation dots
    function renderDots() {
      const container = document.getElementById('dotsContainer');
      container.innerHTML = '';
      const maxDots = Math.min(quizData.sets.length, 30);
      
      for (let i = 0; i < maxDots; i++) {
        const dot = document.createElement('div');
        dot.className = 'dot';
        dot.title = `Set ${i + 1}`;
        if (i === currentSetIndex) dot.classList.add('active');
        if (checkedSets.has(i)) dot.classList.add('completed');
        dot.onclick = () => jumpToSet(i);
        container.appendChild(dot);
      }
      
      // Add indicator if there are more sets
      if (quizData.sets.length > 30) {
        const more = document.createElement('span');
        more.style.color = '#64748b';
        more.style.fontSize = '0.75rem';
        more.style.marginLeft = '0.5rem';
        more.textContent = `+${quizData.sets.length - 30} more`;
        container.appendChild(more);
      }
    }

    // Load multiple sets
    function loadMultipleSets(startIndex, count) {
      const container = document.getElementById('setsContainer');
      const endIndex = Math.min(startIndex + count, quizData.sets.length);
      
      for (let i = startIndex; i < endIndex; i++) {
        if (!visibleSets.includes(i)) {
          visibleSets.push(i);
          container.appendChild(createSetElement(i));
        }
      }
      
      totalLoaded = endIndex;
      updateWordBankForSet(currentSetIndex);
    }

    // Create set element
    function createSetElement(setIndex) {
      const set = quizData.sets[setIndex];
      const wrapper = document.createElement('div');
      wrapper.className = 'set-wrapper';
      wrapper.id = `set-${setIndex}`;
      wrapper.dataset.setIndex = setIndex;
      
      // Set header
      const header = document.createElement('div');
      header.className = 'set-header';
      
      const title = document.createElement('div');
      title.className = 'set-title';
      title.textContent = `Set ${setIndex + 1} of ${quizData.sets.length}`;
      
      const progress = document.createElement('div');
      progress.className = 'set-progress';
      progress.id = `progress-${setIndex}`;
      progress.textContent = '0/' + set.sentences.length + ' answered';
      
      header.appendChild(title);
      header.appendChild(progress);
      
      // Questions container
      const questionsDiv = document.createElement('div');
      questionsDiv.className = 'quiz-box';
      questionsDiv.style.border = 'none';
      questionsDiv.style.padding = '0';
      questionsDiv.style.background = 'none';
      
      set.sentences.forEach((sentence, idx) => {
        questionsDiv.appendChild(createQuestionElement(setIndex, idx, sentence));
      });
      
      // Set controls
      const controls = document.createElement('div');
      controls.className = 'controls';
      controls.style.marginTop = '0.75rem';
      controls.innerHTML = `
        <button class="control-btn" onclick="checkSet(${setIndex})">Check Set</button>
        <button class="control-btn" onclick="resetSet(${setIndex})">Reset Set</button>
        <button class="control-btn" onclick="focusSet(${setIndex})">Focus This</button>
      `;
      
      wrapper.appendChild(header);
      wrapper.appendChild(questionsDiv);
      wrapper.appendChild(controls);
      
      return wrapper;
    }

    // Create question element
    function createQuestionElement(setIndex, sentenceIndex, sentence) {
      const questionDiv = document.createElement('div');
      questionDiv.className = 'question';
      
      const header = document.createElement('div');
      header.className = 'question-header';
      
      const numBadge = document.createElement('div');
      numBadge.className = 'question-num';
      numBadge.id = `badge-${setIndex}-${sentenceIndex}`;
      numBadge.textContent = sentenceIndex + 1;
      
      const textDiv = document.createElement('div');
      textDiv.className = 'question-text';
      
      const parts = sentence.text.split('_____');
      textDiv.innerHTML = parts[0];
      
      const blank = document.createElement('span');
      blank.className = 'blank';
      blank.id = `blank-${setIndex}-${sentenceIndex}`;
      blank.dataset.set = setIndex;
      blank.dataset.sentence = sentenceIndex;
      blank.textContent = '_____';
      
      // Make it clickable
      blank.onclick = () => selectBlank(setIndex, sentenceIndex);
      
      // Make it droppable
      blank.addEventListener('dragover', handleDragOver);
      blank.addEventListener('drop', handleDrop);
      blank.addEventListener('dragleave', handleDragLeave);
      
      textDiv.appendChild(blank);
      if (parts[1]) textDiv.innerHTML += parts[1];
      
      header.appendChild(numBadge);
      header.appendChild(textDiv);
      questionDiv.appendChild(header);
      
      return questionDiv;
    }

    // Keyboard shortcuts
    function setupKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        // Number keys 1-9 for word selection
        if (e.key >= '1' && e.key <= '9' && activeBlank) {
          const wordIndex = parseInt(e.key) - 1;
          const words = document.querySelectorAll('.word-chip:not(.used)');
          if (words[wordIndex]) {
            fillBlankWithWord(activeBlank.set, activeBlank.sentence, words[wordIndex].dataset.wordIndex);
          }
        }
        
        // Tab for next blank
        if (e.key === 'Tab') {
          e.preventDefault();
          navigateToNextBlank(e.shiftKey);
        }
        
        // Arrow keys for set navigation
        if (e.key === 'ArrowLeft') navigateSet(-1);
        if (e.key === 'ArrowRight') navigateSet(1);
        
        // Ctrl+Enter to check all
        if (e.ctrlKey && e.key === 'Enter') {
          checkAllVisible();
        }
        
        // Ctrl+G for goto
        if (e.ctrlKey && e.key === 'g') {
          e.preventDefault();
          document.getElementById('gotoInput').focus();
        }
        
        // Escape to deselect
        if (e.key === 'Escape') {
          deselectAllBlanks();
        }
      });
    }

    // Touch gestures for mobile
    function setupTouchGestures() {
      let touchStartTime = 0;
      let touchStartX = 0;
      let touchStartY = 0;
      
      document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      });
      
      document.addEventListener('touchend', (e) => {
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const touchDuration = Date.now() - touchStartTime;
        
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Only process horizontal swipes
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50 && touchDuration < 500) {
          if (deltaX > 0) {
            navigateSet(-1);
            showGesture('‚Üê Previous Set');
          } else {
            navigateSet(1);
            showGesture('Next Set ‚Üí');
          }
        }
      });
    }

    // Show gesture feedback
    function showGesture(text) {
      const indicator = document.getElementById('gestureIndicator');
      indicator.textContent = text;
      indicator.classList.add('show');
      setTimeout(() => indicator.classList.remove('show'), 1000);
    }

    // FIXED: Drag and Drop implementation
    function setupDragAndDrop() {
      // Use event delegation for dynamically created elements
      document.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('word-chip') && !e.target.classList.contains('used')) {
          e.target.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', e.target.dataset.wordIndex);
        }
      });
      
      document.addEventListener('dragend', (e) => {
        if (e.target.classList.contains('word-chip')) {
          e.target.classList.remove('dragging');
        }
      });
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      e.currentTarget.classList.add('drag-over');
    }

    function handleDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');
      
      const wordIndex = e.dataTransfer.getData('text/plain');
      if (wordIndex !== null && wordIndex !== '') {
        const setIndex = parseInt(e.currentTarget.dataset.set);
        const sentenceIndex = parseInt(e.currentTarget.dataset.sentence);
        fillBlankWithWord(setIndex, sentenceIndex, parseInt(wordIndex));
      }
    }

    // Infinite scroll
    function setupInfiniteScroll() {
      let loading = false;
      
      window.addEventListener('scroll', () => {
        if (loading) return;
        
        const scrollPosition = window.innerHeight + window.scrollY;
        const documentHeight = document.documentElement.offsetHeight;
        
        if (scrollPosition >= documentHeight - 500 && totalLoaded < quizData.sets.length) {
          loading = true;
          loadMultipleSets(totalLoaded, SETS_TO_LOAD);
          setTimeout(() => loading = false, 100);
        }
      });
    }

    // Select blank for keyboard/click input
    function selectBlank(setIndex, sentenceIndex) {
      deselectAllBlanks();
      activeBlank = { set: setIndex, sentence: sentenceIndex };
      const blank = document.getElementById(`blank-${setIndex}-${sentenceIndex}`);
      blank.classList.add('active');
      blank.classList.add('keyboard-focus');
      updateWordBankForSet(setIndex);
      
      // Auto-scroll to make sure it's visible
      blank.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }

    function deselectAllBlanks() {
      document.querySelectorAll('.blank').forEach(b => {
        b.classList.remove('active', 'keyboard-focus');
      });
      activeBlank = null;
    }

    // Fill blank with word
    function fillBlankWithWord(setIndex, sentenceIndex, wordIndex) {
      const key = `${setIndex}-${sentenceIndex}`;
      userAnswers[key] = parseInt(wordIndex);
      
      const blank = document.getElementById(`blank-${setIndex}-${sentenceIndex}`);
      const shuffled = shuffledWords[setIndex];
      blank.textContent = shuffled.words[wordIndex];
      blank.classList.add('filled');
      
      // Update badge
      const badge = document.getElementById(`badge-${setIndex}-${sentenceIndex}`);
      badge.classList.add('answered');
      
      // Update progress
      updateSetProgress(setIndex);
      updateInfoBar();
      updateWordBankForSet(setIndex);
      
      // Auto-advance to next blank
      autoAdvanceToNext(setIndex, sentenceIndex);
      
      // Auto-save
      saveProgress();
    }

    // Auto-advance to next empty blank
    function autoAdvanceToNext(currentSet, currentSentence) {
      const set = quizData.sets[currentSet];
      
      // Try next in same set
      for (let i = currentSentence + 1; i < set.sentences.length; i++) {
        const key = `${currentSet}-${i}`;
        if (!userAnswers[key]) {
          selectBlank(currentSet, i);
          return;
        }
      }
      
      // Try next set
      if (currentSet < totalLoaded - 1) {
        const nextSet = currentSet + 1;
        const nextSetData = quizData.sets[nextSet];
        for (let i = 0; i < nextSetData.sentences.length; i++) {
          const key = `${nextSet}-${i}`;
          if (!userAnswers[key]) {
            selectBlank(nextSet, i);
            return;
          }
        }
      }
      
      deselectAllBlanks();
    }

    // Navigate to next/previous blank
    function navigateToNextBlank(reverse = false) {
      const blanks = document.querySelectorAll('.blank');
      const blankArray = Array.from(blanks);
      
      if (blankArray.length === 0) return;
      
      let currentIndex = -1;
      if (activeBlank) {
        const currentId = `blank-${activeBlank.set}-${activeBlank.sentence}`;
        currentIndex = blankArray.findIndex(b => b.id === currentId);
      }
      
      let nextIndex = reverse ? currentIndex - 1 : currentIndex + 1;
      
      if (nextIndex < 0) nextIndex = blankArray.length - 1;
      if (nextIndex >= blankArray.length) nextIndex = 0;
      
      const nextBlank = blankArray[nextIndex];
      const setIndex = parseInt(nextBlank.dataset.set);
      const sentenceIndex = parseInt(nextBlank.dataset.sentence);
      
      selectBlank(setIndex, sentenceIndex);
    }

    // Update word bank for specific set
    function updateWordBankForSet(setIndex) {
      if (!quizData || setIndex >= quizData.sets.length) return;
      
      currentSetIndex = setIndex;
      const set = quizData.sets[setIndex];
      const shuffled = shuffledWords[setIndex];
      const wordBank = document.getElementById('wordBank');
      
      wordBank.innerHTML = '';
      
      shuffled.words.forEach((word, idx) => {
        const chip = document.createElement('div');
        chip.className = 'word-chip';
        chip.textContent = word;
        chip.draggable = true;
        chip.dataset.wordIndex = idx;
        
        // Check if used
        let isUsed = false;
        Object.keys(userAnswers).forEach(key => {
          const [s, _] = key.split('-');
          if (parseInt(s) === setIndex && userAnswers[key] === idx) {
            isUsed = true;
          }
        });
        
        if (isUsed) chip.classList.add('used');
        
        // Click to fill active blank
        chip.onclick = () => {
          if (!isUsed && activeBlank && activeBlank.set === setIndex) {
            fillBlankWithWord(activeBlank.set, activeBlank.sentence, idx);
          }
        };
        
        wordBank.appendChild(chip);
      });
    }

    // Update set progress
    function updateSetProgress(setIndex) {
      const set = quizData.sets[setIndex];
      let answered = 0;
      
      set.sentences.forEach((_, idx) => {
        const key = `${setIndex}-${idx}`;
        if (userAnswers[key] !== undefined) answered++;
      });
      
      const progress = document.getElementById(`progress-${setIndex}`);
      if (progress) {
        progress.textContent = `${answered}/${set.sentences.length} answered`;
      }
    }

    // Navigate sets
    function navigateSet(direction) {
      const newIndex = currentSetIndex + direction;
      if (newIndex >= 0 && newIndex < quizData.sets.length) {
        jumpToSet(newIndex);
      }
    }

    // Jump to specific set
    function jumpToSet(setIndex) {
      // Load if not already loaded
      if (setIndex >= totalLoaded) {
        loadMultipleSets(totalLoaded, Math.max(SETS_TO_LOAD, setIndex - totalLoaded + 1));
      }
      
      currentSetIndex = setIndex;
      const element = document.getElementById(`set-${setIndex}`);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
      
      updateWordBankForSet(setIndex);
      updateNavButtons();
      updateDots();
    }

    // Focus on specific set
    function focusSet(setIndex) {
      // Hide all other sets temporarily
      document.querySelectorAll('.set-wrapper').forEach(s => {
        if (parseInt(s.dataset.setIndex) !== setIndex) {
          s.style.display = 'none';
        }
      });
      
      // Show only focused set
      const focusedSet = document.getElementById(`set-${setIndex}`);
      focusedSet.style.display = 'block';
      focusedSet.scrollIntoView({ behavior: 'smooth', block: 'start' });
      
      // Add unfocus button
      const controls = focusedSet.querySelector('.controls');
      const unfocusBtn = document.createElement('button');
      unfocusBtn.className = 'control-btn';
      unfocusBtn.textContent = 'Show All Sets';
      unfocusBtn.onclick = () => {
        document.querySelectorAll('.set-wrapper').forEach(s => {
          s.style.display = 'block';
        });
        unfocusBtn.remove();
      };
      controls.appendChild(unfocusBtn);
      
      updateWordBankForSet(setIndex);
    }

    // FIXED: Check individual set with proper color feedback
    function checkSet(setIndex) {
      const set = quizData.sets[setIndex];
      const shuffled = shuffledWords[setIndex];
      
      set.sentences.forEach((sentence, idx) => {
        const key = `${setIndex}-${idx}`;
        if (userAnswers[key] !== undefined) {
          const blank = document.getElementById(`blank-${setIndex}-${idx}`);
          const badge = document.getElementById(`badge-${setIndex}-${idx}`);
          
          const correctShuffledIdx = shuffled.indexMap[sentence.correct];
          
          if (userAnswers[key] === correctShuffledIdx) {
            blank.classList.add('correct');
            blank.classList.remove('incorrect');
            badge.classList.add('correct');
            badge.classList.remove('incorrect');
          } else {
            blank.classList.add('incorrect');
            blank.classList.remove('correct');
            badge.classList.add('incorrect');
            badge.classList.remove('correct');
          }
        }
      });
      
      checkedSets.add(setIndex);
      updateDots();
      saveProgress();
    }

    // Reset individual set
    function resetSet(setIndex) {
      const set = quizData.sets[setIndex];
      
      set.sentences.forEach((_, idx) => {
        const key = `${setIndex}-${idx}`;
        delete userAnswers[key];
        
        const blank = document.getElementById(`blank-${setIndex}-${idx}`);
        const badge = document.getElementById(`badge-${setIndex}-${idx}`);
        
        if (blank) {
          blank.textContent = '_____';
          blank.classList.remove('filled', 'correct', 'incorrect');
        }
        
        if (badge) {
          badge.classList.remove('answered', 'correct', 'incorrect');
        }
      });
      
      checkedSets.delete(setIndex);
      updateSetProgress(setIndex);
      updateWordBankForSet(setIndex);
      updateDots();
      updateInfoBar();
      saveProgress();
    }

    // Check all visible sets
    function checkAllVisible() {
      visibleSets.forEach(setIndex => checkSet(setIndex));
    }

    // Reset all visible sets
    function resetAllVisible() {
      if (confirm('Reset all visible sets? This will clear your answers.')) {
        visibleSets.forEach(setIndex => resetSet(setIndex));
      }
    }

    // Find next unanswered
    function nextUnanswered() {
      for (let s = 0; s < quizData.sets.length; s++) {
        const set = quizData.sets[s];
        for (let i = 0; i < set.sentences.length; i++) {
          const key = `${s}-${i}`;
          if (!userAnswers[key]) {
            jumpToSet(s);
            selectBlank(s, i);
            return;
          }
        }
      }
      alert('All questions have been answered!');
    }

    // Update navigation buttons
    function updateNavButtons() {
      document.getElementById('prevBtn').disabled = currentSetIndex === 0;
      document.getElementById('nextBtn').disabled = currentSetIndex === quizData.sets.length - 1;
    }

    // Update dots
    function updateDots() {
      const dots = document.querySelectorAll('.dot');
      dots.forEach((dot, idx) => {
        dot.classList.toggle('active', idx === currentSetIndex);
        dot.classList.toggle('completed', checkedSets.has(idx));
      });
    }

    // Update info bar
    function updateInfoBar() {
      const totalAnswered = Object.keys(userAnswers).length;
      const totalQuestions = quizData.sets.reduce((sum, set) => sum + set.sentences.length, 0);
      const setsCompleted = checkedSets.size;
      
      document.getElementById('infoBar').textContent = 
        `${totalAnswered}/${totalQuestions} answered ‚Ä¢ ${setsCompleted}/${quizData.sets.length} sets checked ‚Ä¢ Set ${currentSetIndex + 1} active`;
    }

    // Show results
    function showResults() {
      let totalCorrect = 0;
      let totalAnswered = 0;
      
      checkedSets.forEach(setIndex => {
        const set = quizData.sets[setIndex];
        const shuffled = shuffledWords[setIndex];
        
        set.sentences.forEach((sentence, idx) => {
          const key = `${setIndex}-${idx}`;
          if (userAnswers[key] !== undefined) {
            totalAnswered++;
            const correctShuffledIdx = shuffled.indexMap[sentence.correct];
            if (userAnswers[key] === correctShuffledIdx) {
              totalCorrect++;
            }
          }
        });
      });
      
      const percentage = totalAnswered > 0 ? Math.round((totalCorrect / totalAnswered) * 100) : 0;
      
      document.getElementById('resultsContent').innerHTML = `
        <div class="modal-stat"><strong>Sets Checked:</strong> ${checkedSets.size}/${quizData.sets.length}</div>
        <div class="modal-stat"><strong>Questions Answered:</strong> ${totalAnswered}</div>
        <div class="modal-stat"><strong>Correct Answers:</strong> ${totalCorrect}</div>
        <div class="modal-stat"><strong>Accuracy:</strong> ${percentage}%</div>
        <div class="modal-stat"><strong>Sets Loaded:</strong> ${totalLoaded}/${quizData.sets.length}</div>
      `;
      
      document.getElementById('resultsModal').classList.add('active');
    }

    function closeModal() {
      document.getElementById('resultsModal').classList.remove('active');
    }

    // Save/Load progress
    function saveProgress() {
      const data = {
        answers: userAnswers,
        checked: Array.from(checkedSets),
        currentSet: currentSetIndex,
        timestamp: new Date().toISOString()
      };
      
      localStorage.setItem('intuityQuizProgress', JSON.stringify(data));
      
      // Quick visual feedback
      const saveBtn = document.querySelector('[onclick="saveProgress()"]');
      if (saveBtn) {
        const originalText = saveBtn.textContent;
        saveBtn.textContent = '‚úì Saved!';
        setTimeout(() => {
          saveBtn.textContent = originalText;
        }, 1000);
      }
    }

    function loadSavedProgress() {
      try {
        const saved = localStorage.getItem('intuityQuizProgress');
        if (saved) {
          const data = JSON.parse(saved);
          userAnswers = data.answers || {};
          checkedSets = new Set(data.checked || []);
          
          // Restore visual state after load
          setTimeout(() => {
            Object.keys(userAnswers).forEach(key => {
              const [setIndex, sentenceIndex] = key.split('-').map(Number);
              if (setIndex < totalLoaded) {
                const blank = document.getElementById(`blank-${setIndex}-${sentenceIndex}`);
                const badge = document.getElementById(`badge-${setIndex}-${sentenceIndex}`);
                
                if (blank && shuffledWords[setIndex]) {
                  const shuffled = shuffledWords[setIndex];
                  blank.textContent = shuffled.words[userAnswers[key]];
                  blank.classList.add('filled');
                  badge?.classList.add('answered');
                }
              }
            });
            
            // Check completed sets
            checkedSets.forEach(setIndex => {
              if (setIndex < totalLoaded) {
                checkSet(setIndex);
              }
            });
            
            updateInfoBar();
          }, 100);
        }
      } catch (e) {
        console.error('Error loading saved progress:', e);
      }
    }

    function goBack() {
      window.location.href = '../similar-words.html';
    }

    // Start the application
    window.onload = init;
  </script>
</body>
</html>
